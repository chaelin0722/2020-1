### Algorithm 0715

<hr>

### 정렬



정렬 알고리즘은 대부분 O(n^2) 와 O(nlogn) 사이에 있다. 

input 이 특수한 성질을 만족하는 경우에는 O(n) sorting 도 가능하다. 



**아래의 세 알고리즘은 대체로 n^2의 시간이 소요되는 정렬 알고리즘이다.**

#### 선택 정렬 

> 주어진 배열에서 가장 큰 수를 찾아 맨 오른쪽수와 바꿔치기하고, 그 수를 제외한 n-1 배열에서 또 가장 큰수를 찾아 맨 오른쪽과 바꿔치기한다. 이렇게 점점 배열은 줄어든다. 단, 데이터의 안정성이 없다. 계속 자리를 바꿔가며 정렬을 진행하므로.. 

 worst case, average case = O(n^2)

만약 정렬이 다 된 경우에도 모드 자리수를 다 탐색해야 하니 n 제곱이 나온다. 



#### 버블정렬

> 바로 옆 원소와 비교하면서 원소교환을 한다. 배열을 한 번 돌때마다 맨 오른쪽에 큰 값이 정렬되어 하나씩 배열을 줄여가며 진행한다.

이미 정렬되어 있는 경우에도 의미 없이 순환함   => 개선방안 !  p.92

sorted 라는 플래그 변수를 둔다.  교환이 필요하면 교환 후 sorted를 false로 바꾼다 

 worst case, average case = O(n^2)



#### 삽입 정렬

> 이미 정렬되어있는 i개짜리 배열에 하나의 원소를 더 더해 정렬된 i + 1 개짜리 배열을 만드는 과정을 반복. 
>
> 선택과 버블정렬이 n 개 배열에서 시작해 크기를 하나씩 줄이는데 반해, 삽입 정렬은 한 개짜리 배열에서 시작해 그 크기를 하나씩 늘리는 정렬이다. 

 worst case, average case = O(n^2)

best case = O(n)

거의 입력되어 있는 상태의 경우에 유리하다. 



<hr>



### 고급 정렬 알고리즘

> O(nlogn) 이 보장되는 알고리즘 3가지 (병합정렬, 퀵정렬, 힙정렬)



#### 병합정렬 (merge sort)

> 입력을 반으로 나눈 후 정렬해 다시 합쳐 정렬된 하나의 배열을 만든다. 



#### 퀵정렬 (quick sort)

> 기준 원소 하나를 정하고 기준보다 작은 수는 왼쪽, 나머지는 오른쪽에 오도록 재배치 한다. 
>
> 그 후 왼쪽 부분 배열 정렬, 오른쪽 부분 배열 정렬을 한다. 

선택한 기준값이 끝값일 경우  O(n^2) 이 나올 수 있다.



#### 힙정렬 (Heap sort)

>  입력받은 데이터 배열은 먼저 힙으로 만들어준 후 정렬을 한다. 힙화하는데 n^2, 정렬이 logn 의 시간이 걸려 최악의 경우 nlogn 의 시간이 걸리게 된다.



**위의 여섯가지 알고리즘들은 원소 두 개를 비교함으로써 정렬하는 <<비교정렬>>이다. 즉, 원소의 상대적인 대소 관계만 판단할 뿐, 원소의 분포나 자릿수 등은 고려하지 않았다. **

**따라서 비교 정렬은 최악의 경우 수행시간이 nlogn 보다 빨라질 수 는 없다.**

아래의 두 알고리즘은 입력 원소들이 특수한 성질은 만족하는 경우에 nlogn의 한계를 극복함을 보여준다.



#### 계수정렬



#### 기수정렬







